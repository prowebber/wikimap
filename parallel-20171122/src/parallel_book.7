.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PARALLEL_BOOK 7"
.TH PARALLEL_BOOK 7 "2017-11-22" "20171022" "parallel"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Learn GNU Parallel in 5 minutes"
.IX Header "Learn GNU Parallel in 5 minutes"
You just need to run commands in parallel. You do not care about fine
tuning.
.PP
To get going please run this to make some example files:
.PP
.Vb 2
\&  # If your system does not have \*(Aqseq\*(Aq, we will use \*(Aqjot\*(Aq instead
\&  if ! seq 1 2>/dev/null; then alias seq=jot; fi
\&
\&  seq 5 | parallel \*(Aqseq {} > example.{}\*(Aq
.Ve
.SS "Input sources"
.IX Subsection "Input sources"
\&\s-1GNU \s0\fBparallel\fR reads values from input sources. One input source is
the command line. The values are put after \fB:::\fR :
.PP
.Vb 1
\&  parallel echo ::: 1 2 3 4 5
.Ve
.PP
This makes it easy to run the same program on some files:
.PP
.Vb 1
\&  parallel wc ::: example.*
.Ve
.PP
If you give multiple \fB:::\fRs, \s-1GNU \s0\fBparallel\fR will make all combinations:
.PP
.Vb 1
\&  parallel wc ::: \-l \-c ::: example.*
.Ve
.PP
\&\s-1GNU \s0\fBparallel\fR can also read the values from stdin (standard input):
.PP
.Vb 1
\&  seq 5 | parallel echo
.Ve
.SS "Building the command line"
.IX Subsection "Building the command line"
The command line is put before the \fB:::\fR. It can contain contain a
command and options for the command:
.PP
.Vb 1
\&  parallel wc \-l ::: example.*
.Ve
.PP
The command can contain multiple programs. Just remember to quote
characters that are interpreted by the shell (such as \fB;\fR):
.PP
.Vb 1
\&  parallel echo counting lines\*(Aq;\*(Aq wc \-l ::: example.*
.Ve
.PP
The value will normally be appended to the command, but can be placed
anywhere by using the replacement string \fB{}\fR:
.PP
.Vb 1
\&  parallel echo counting {}\*(Aq;\*(Aq wc \-l {} ::: example.*
.Ve
.PP
When using multiple input sources you use the positional replacement
strings:
.PP
.Vb 1
\&  parallel echo count {1} in {2}\*(Aq;\*(Aq wc {1} {2} ::: \-l \-c ::: example.*
.Ve
.SS "Controlling the output"
.IX Subsection "Controlling the output"
The output will be printed as soon as the command completes. This
means the output may come in a different order than the input:
.PP
.Vb 1
\&  parallel sleep {}\*(Aq;\*(Aq echo {} done ::: 5 4 3 2 1
.Ve
.PP
You can force \s-1GNU \s0\fBparallel\fR to print in the order of the values with
\&\fB\-\-keep\-order\fR/\fB\-k\fR. This will still run the commands in parallel.
The output of the later jobs will be delayed, until the earlier jobs
are printed:
.PP
.Vb 1
\&  parallel \-k sleep {}\*(Aq;\*(Aq echo {} done ::: 5 4 3 2 1
.Ve
.SS "Controlling the execution"
.IX Subsection "Controlling the execution"
If your jobs are compute intensive, you will most likely run one job
for each core in the system. This is the default for \s-1GNU \s0\fBparallel\fR.
.PP
But sometimes you want more jobs running. You control the number of
job slots with \fB\-j\fR. Give \fB\-j\fR the number of jobs to run in
parallel:
.PP
.Vb 4
\&  parallel \-j50 \e
\&    wget http://ftpmirror.gnu.org/parallel/parallel\-{1}{2}22.tar.bz2 \e
\&    ::: 2012 2013 2014 2015 2016 \e
\&    ::: 01 02 03 04 05 06 07 08 09 10 11 12
.Ve
.SS "Pipe mode"
.IX Subsection "Pipe mode"
\&\s-1GNU \s0\fBparallel\fR can also pass blocks of data to commands on stdin
(standard input):
.PP
.Vb 1
\&  seq 1000000 | parallel \-\-pipe wc
.Ve
.PP
This can be used to process big text files. By default \s-1GNU \s0\fBparallel\fR
splits on \en (newline) and passes a block of around 1 \s-1MB\s0 to each job.
.SS "That's it"
.IX Subsection "That's it"
You have now learned the basic use of \s-1GNU \s0\fBparallel\fR. This will
probably cover most cases of your use of \s-1GNU \s0\fBparallel\fR.
.PP
The rest of this document is simply to go into more details on each of
the sections and cover special use cases.
.SH "Learn GNU Parallel in an hour"
.IX Header "Learn GNU Parallel in an hour"
In this part we will dive deeper into what you learned in the first 5 minutes.
.PP
To get going please run this to make some example files:
.PP
.Vb 2
\&  seq 6 > seq6
\&  seq 6 \-1 1 > seq\-6
.Ve
.SS "Input sources"
.IX Subsection "Input sources"
On top of the command line, input sources can also be stdin (standard
input or '\-'), files and fifos and they can be mixed. Files are given
after \fB\-a\fR or \fB::::\fR. So these all do the same:
.PP
.Vb 7
\&  parallel echo Dice1={1} Dice2={2} ::: 1 2 3 4 5 6 ::: 6 5 4 3 2 1
\&  parallel echo Dice1={1} Dice2={2} ::: <(seq 6) ::: <(seq 6 \-1 1)
\&  parallel echo Dice1={1} Dice2={2} :::: seq6 seq\-6
\&  parallel \-a seq6 \-a seq\-6 echo Dice1={1} Dice2={2}
\&  parallel \-a seq6 echo Dice1={1} Dice2={2} :::: seq\-6
\&  parallel echo Dice1={1} Dice2={2} ::: 1 2 3 4 5 6 :::: seq\-6
\&  cat seq\-6 | parallel echo Dice1={1} Dice2={2} :::: seq\-6 \-
.Ve
.PP
If stdin (standard input) is the only input source, you do not need the '\-':
.PP
.Vb 1
\&  cat seq6 | parallel echo Dice1={1}
.Ve
.PP
You can link multiple input sources with \fB:::+\fR and \fB::::+\fR:
.PP
.Vb 2
\&  parallel echo {1}={2} ::: I II III IV V VI :::+ 1 2 3 4 5 6
\&  parallel echo {1}={2} ::: I II III IV V VI ::::+ seq6
.Ve
.SS "Building the command line"
.IX Subsection "Building the command line"
\fIThe command\fR
.IX Subsection "The command"
.PP
The command can be a script, a binary or a Bash function if the
function is exported using \fBexport \-f\fR:
.PP
.Vb 6
\&  # Works only in Bash
\&  my_func() {
\&    echo in my_func "$1"
\&  }
\&  export \-f my_func
\&  parallel my_func ::: 1 2 3
.Ve
.PP
\fIThe replacement strings\fR
.IX Subsection "The replacement strings"
.PP
\&\s-1GNU \s0\fBparallel\fR has some replacement strings to make it easier
.SS "Controlling the output"
.IX Subsection "Controlling the output"
.SS "Controlling the execution"
.IX Subsection "Controlling the execution"
\fIRemote execution\fR
.IX Subsection "Remote execution"
.SS "Pipe mode =head2 That's it"
.IX Subsection "Pipe mode =head2 That's it"
.SH "Advanced usage"
.IX Header "Advanced usage"
env_parallel, parset, env_parset
